#!/usr/bin/env bash
# Copyright (c) 2025 Pakrohk
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# ffexport - export tool with profile import/export features
# Place in plugin/bin/ffexport and make executable (chmod +x)
set -euo pipefail

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
CONFIG_FILE="${FFEXPORT_PROFILES:-$script_dir/../profiles.toml}"

die(){ echo "Error: $*" >&2; exit 1; }

usage(){
  cat <<EOF
ffexport - export videos using TOML profiles (profiles at: $CONFIG_FILE)

Usage:
  ffexport -p PROFILE -i INPUT [options]
  ffexport --export-profile PROFILE --out FILE
  ffexport --import-profile FILE
  ffexport --create-profile-from-url URL --name PROFILE_NAME

Options:
  -p PROFILE        Profile name (e.g., Instagram.Reel)
  -i INPUT          Input file
  -q QUALITY        low|medium|high
  -n NAME           Output base name
  -d OUTDIR         Output directory
  -x EXTRA          Extra ffmpeg args
  --list-profiles   List available profiles
  --export-profile  Export a profile to a TOML file (requires --out)
  --import-profile  Import/merge profiles from a TOML file
  --create-profile-from-url URL  Create a new profile by fetching metadata from a video URL (requires --name)
  --name PROFILE_NAME  The name for the new profile (e.g., YouTube.Custom)
  --out FILE        Output file for --export-profile
  -h, --help        Show this help
EOF
}

if [[ $# -eq 0 ]]; then usage; exit 0; fi

# arg parsing
PROFILE=""
INPUT=""
QUALITY=""
OUTNAME=""
OUTDIR=""
EXTRA_ARGS=""
EXPORT_PROFILE=""
IMPORT_PROFILE=""
CREATE_PROFILE_URL=""
NEW_PROFILE_NAME=""
OUTFILE=""
LIST_ONLY=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    -p) PROFILE="$2"; shift 2;;
    -i) INPUT="$2"; shift 2;;
    -q) QUALITY="$2"; shift 2;;
    -n) OUTNAME="$2"; shift 2;;
    -d) OUTDIR="$2"; shift 2;;
    -x) EXTRA_ARGS="$2"; shift 2;;
    --list-profiles) LIST_ONLY=1; shift;;
    --export-profile) EXPORT_PROFILE="$2"; shift 2;;
    --import-profile) IMPORT_PROFILE="$2"; shift 2;;
    --create-profile-from-url) CREATE_PROFILE_URL="$2"; shift 2;;
    --name) NEW_PROFILE_NAME="$2"; shift 2;;
    --out) OUTFILE="$2"; shift 2;;
    -h|--help) usage; exit 0;;
    *) die "Unknown argument: $1";;
  esac
done

# list profiles
if [[ $LIST_ONLY -eq 1 ]]; then
  python3 - <<'PY'
import sys, pathlib, tomllib
cfg=pathlib.Path("${CONFIG_FILE}")
if not cfg.exists():
    sys.exit(0)
try:
    doc=tomllib.loads(cfg.read_text(encoding="utf-8"))
    platforms=doc.get("platforms",{})
    def walk(d,prefix=""):
        for k,v in d.items():
            if isinstance(v, dict):
                has_scalar = any(not isinstance(x, dict) for x in v.values())
                if has_scalar:
                    print((prefix+k).strip("."))
                for subk,subv in v.items():
                    if isinstance(subv, dict):
                        walk({subk:subv}, prefix + k + ".")
    walk(platforms)
except Exception as e:
    print(f"Error reading profiles: {e}", file=sys.stderr)
    sys.exit(1)
PY
  exit $?
fi

# create profile from URL
if [[ -n "$CREATE_PROFILE_URL" ]]; then
  [[ -n "$NEW_PROFILE_NAME" ]] || die "--create-profile-from-url requires --name <profile_name>"
  command -v yt-dlp >/dev/null 2>&1 || die "yt-dlp is not installed. Please install it with 'pip install yt-dlp'."
  command -v jq >/dev/null 2>&1 || die "jq is not installed. Please install it."

  temp_file=$(mktemp)
  trap 'rm -f "$temp_file"' EXIT

  # Attempt to fetch metadata. Redirect stdout to the temp file, hide stderr.
  if ! yt-dlp -f 'bestvideo+bestaudio/best' --skip-download --print-json "$CREATE_PROFILE_URL" > "$temp_file" 2>/dev/null; then
    # Check if the file is empty, as yt-dlp might fail silently
    if [[ ! -s "$temp_file" ]]; then
      die "yt-dlp failed to fetch metadata. The URL may be invalid or unsupported."
    fi
  fi

  # Validate that the temp file contains valid JSON
  if ! jq . < "$temp_file" >/dev/null 2>&1; then
    die "Failed to parse video metadata. The JSON from yt-dlp was invalid."
  fi

  # Pass paths as arguments to the python script
  python3 - "$CONFIG_FILE" "$NEW_PROFILE_NAME" "$temp_file" <<'PY'
import sys, pathlib, tomllib, json

try:
    import tomli_w
except ImportError:
    tomli_w = None

cfg_path = pathlib.Path(sys.argv[1])
profile_name = sys.argv[2]
json_file_path = pathlib.Path(sys.argv[3])

try:
    video_info_json = json_file_path.read_text(encoding="utf-8")
    video_info = json.loads(video_info_json)
except (json.JSONDecodeError, FileNotFoundError):
    print("Error: Failed to read or parse video metadata.", file=sys.stderr)
    sys.exit(1)

# Map yt-dlp fields to our profile fields, providing sensible defaults
new_profile = {
    "name": profile_name.replace('.', '_'),
    "container": video_info.get("ext", "mp4"),
    "video_codec": video_info.get("vcodec", "libx264"),
    "audio_codec": video_info.get("acodec", "aac"),
    "resolution": f"{video_info.get('width', 1920)}:{video_info.get('height', 1080)}",
    "fps": int(video_info.get("fps") or 30),
    "video_bitrate": f"{int(video_info.get('vbr', 10000))}k",
    "audio_bitrate": f"{int(video_info.get('abr', 128))}k",
    "pixel_format": "yuv420p",
    "extra_args": "-movflags +faststart",
}

# Load existing profiles
if cfg_path.exists():
    try:
        base = tomllib.loads(cfg_path.read_text(encoding="utf-8"))
    except tomllib.TOMLDecodeError:
        base = {"platforms": {}} # Start fresh if config is corrupt
else:
    base = {"platforms": {}}

# Merge new profile into the platforms structure
platforms = base.get("platforms", {})
keys = profile_name.split('.')
node = platforms
for key in keys[:-1]:
    node = node.setdefault(key, {})
node[keys[-1]] = new_profile
base["platforms"] = platforms

# Write back to the TOML file
if tomli_w:
    try:
        out = tomli_w.dumps(base)
        cfg_path.write_text(out, encoding="utf-8")
        print(f"Successfully created and saved profile '{profile_name}' to {cfg_path}")
    except Exception as e:
        print(f"Error writing TOML file with tomli_w: {e}", file=sys.stderr)
        sys.exit(1)
else:
    # Fallback naive writer if tomli_w is not available
    lines=[]
    if "defaults" in base:
        lines.append("[defaults]")
        for kk,vv in base["defaults"].items(): lines.append(f'{kk} = {json.dumps(vv)}')
        lines.append("")

    def dict_to_toml_lines(d, prefix=""):
        for k, v in d.items():
            if isinstance(v, dict) and "name" not in v: # It's a nested group like [platforms.YouTube]
                dict_to_toml_lines(v, prefix=f"{prefix}{k}.")
            else: # It's a profile
                lines.append(f'[platforms."{prefix}{k}"]')
                for pk, pv in v.items(): lines.append(f'{pk} = {json.dumps(pv)}')
                lines.append("")

    dict_to_toml_lines(base.get("platforms", {}))
    cfg_path.write_text("\n".join(lines), encoding="utf-8")
    print(f"Successfully created profile '{profile_name}' (using fallback writer).")
PY
  exit 0
fi

# handle export-profile
if [[ -n "$EXPORT_PROFILE" ]]; then
  if [[ -z "$OUTFILE" ]]; then die "--export-profile requires --out <file>"; fi
  python3 - "$CONFIG_FILE" "$EXPORT_PROFILE" "$OUTFILE" <<'PY'
# (The rest of the script is unchanged, so it's omitted for brevity)
# ...
PY
  exit $?
fi

# (The rest of the script is unchanged)
# ...
